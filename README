----------------
aleatoric README
Mark Weiss
updated: 3/3/2008
----------------

-----------------------------
Background and Code Overview
-----------------------------

Right now this library isn't even that, but is actually a one-off bit of code that renders Terry Riley's "In C" as a Score file in a format that the electronic music composition program CSound can consume in order to render a sound file.

"In C" is a classic of aleatoric music composition, widely recorded and well known.  There are for example renditions by hippie French-Canadian orchestras, modern Chinese orchestras, psychedelic rock bands, and so on.

Two classes model general concepts that are likely to remain in a similar form as the library evolves.

First, a Note (note.rb) models a musical event.  In this case the properties map to the core required properties for a Note in a CSound Score, which are instrument, amplitude, start time, duration and pitch.  Instrument refers to a definition of an electronic instrument in a CSound Orchestra file; the others are typical properties of any musical event.  Given the common model for a musical event in various synthesis systems, a goal of aleatoric is a generic Note API that binds to different back ends for actual sound rendering.  In particular I plan to implement MIDI bindings, and along the way investigate Archaeopteryx (http://github.com/gilesbowkett/archaeopteryx/tree/master) and perhaps other Ruby MIDI libraries.

The second general concept already present in the code is a Score (score.rb), which models a sequence of Notes.  This is essentially a simple collection class with some features and naming semantics particular to this domain.

Two other classes are currently particular implementations for implementing a system that can render "In C," but were written with future generalization in mind.  In fact, the idea of generalizing the Player and Ensemble classes is the motivation for aleatoric, and one can infer future directions for the library from them.
 
A Player (ensemble.rb) models a player in an ensemble performing a piece of music.  In the current version, however, the player directly implements the prescriptive rules defined by the score for "In C."  But the concept itself is general and the library will generalize it, with the goal of not specifying the degree of freedom given the Player relative to any real-world score or musical direction; aleatoric seeks to support the composer in defining the composition and instructions to the Player as he sees fit.  

Similarly, the Ensemble class (ensemble.rb) models an ensemble of players, who together perform a piece of music.  Again, this first version of Ensemble implements the particular rules required to play "In C."

--------------------------
Composition as Computation
--------------------------

In working on this piece, it struck me how aleatoric compositions align very well with a computational model.  For "In C," for example, Riley composed 53 short musical phrases which the members of the ensemble work through sequentially.  In addition the score includes a series of instructions from the composer to the players.  The instructions are guidelines and leave room for the players to make their own choices, reacting to characteristics of a phrase, where they are in the sequence, and most of all to what they are hearing the rest of the ensemble play.  Aleatoric compositions often follow this approach, providing some musical material (input) and some instructions (an algorithm).  So one can think of the ensemble's performance as a computation (actions on input following an algorithm) that produces the final performance (output).  The result of this approach is that no two performances of "In C" or other aleatoric compositions are the same, and that the performances of the same composition by different artists can vary widely.

The code in aleatoric models the Ensemble "interpreting" the rules of the score by defining a series of tunable parameters, all of which are contained in and documented in player.yml and ensemble.yml.  In each iteration of the performance random numbers are tested against the parameters in various predicate functions in Ensemble and Player, mimicking players making decisions in the real performance.

Because of the nature of the performance, which can comprise hundreds or thousands of iterations, the tunable parameters actually vary the performance in subtle and aesthetically discernible and satisfying ways.  So, this approach seems promising and I consider this first output of "In C" a good start, a proof of concept (at least I think it's fairly satisfying to listen to).

-----------------------------------
Motivation and Goals of the Project
-----------------------------------

But working on this code revealed the shortfalls with this first naive attempt, thus providing the motivation for the project.

First, there is no formal connection between the aleatoric rules of the original score and the code.  I attempt to make the connection by having comments in the code quote the rule from Riley's score, next to the code implementing the rule.  But this is convention only, and creates no formal, testable or self-documenting connection between prescriptive score rules and the code the implements them.  This suggested to me the idea of using an approach similar to RSpec to try and unify the rule description and the code.  The approach promises to create structured but nearly natural language descriptions which are in fact executable functions, and also suggests it is possible to create and build on general primitives implementing common compositional goals.

Besides greater coherence, this approach promises something much more powerful: aleatoric would become a system for specifying aesthetic output -- a system for defining and implementing arbitrary, nearly natural language rules to define a software system that produces art.  This seems like a very fertile and open-ended approach, if it can be realized.

An added benefit of such coherence between description and implementation is that testing will become easier.  At this point I've essentially failed to figure out how to write reasonable tests for judging aesthetic output.  Testing for correctness was a manual process of running code, listening to rendered musical output for unexpected behavior, (i.e. - bugs), and then trying fixes and running again.  This is slow and painful, and some human verification (i.e. - listening to the musical output) is unavoidable, because here "bug" is defined as "not what I expected to hear."  But with RSpec-style declarations the expected output could be described, giving guidance to any implementor of the score.

In short, a general aleatoric library promises a better way.

---------------------------------------------------------------
A Little About Me and the Help I'd Love to Have on This Project
---------------------------------------------------------------

I'm quite non-expert in just about everything this project needs to reach it's potential.  I have very scant knowledge of music theory and composition.  I know just enough of CSound to scratch the surface.  I've never written MIDI software.  This is my first real project in Ruby.  I have little formal experience with DSLs.  I've never worked with RSpec; I don't even do TDD.

Finally, I'm pretty new to open source and have never promoted a project and have no idea, yet, how to do that.

All I am right now is a person with an idea.  If you think you can help and are interested, please drop me a line: marksweiss at yahoo.

-----
Usage
-----

All parameters are defined in three YAML configs, player.yml, ensemble.yml and csound.yml.  Comments in these files describe the affect of the parameters on the output.  In order to really understand their effect, you need to tweak them, run the script and listen to the results.

The application is written in Ruby, and tested on 1.8.6 on Windows.  You'll need Ruby installed to run it.

To run the application and generate a Score file, you simply run the command line 'ruby in_c.rb'.  Right now there is one optional argument '--render_only' which you can use to run the program but not wait on CSound to render.  This is useful if you are just debugging an merely want to see stdout debugging messages, etc.

All other configuration comes from the three .yml files.

To render your Score into a sound file you can listen to, you need the CSound binary.  Running the script produces a CSound Score file, which it then passes to CSound to render into a binary sound file.  CSound is a venerable open source project, and happens to be an incredibly rich and useful tool for electronic music synthesis and composition.  Versions exist for Linux, Mac and Windows, available here: http://csound.sourceforge.net/#Downloads.

Currently the script assumes CSound in the directory where it's running, but you could add a config entry to csound.yml and modify in_c.rb::render_output() to change this.  

The repo includes a CSound .orc Orchestra file, defining a simple two-channel oscillator instrument.  This instrument eschews even basic FM synthesis and produces simple output in order to promote focus on the output from the parameterized system and on the effect of changing parameters.
